class GuessItException extends Error { constructor(inputString, options, originalError = null) { const version = "1.0.0"; const message = [ "An internal error has occurred in guessit-js.", "===================== Guessit Exception Report =====================", `version=${version}`, `string=${inputString}`, `options=${JSON.stringify(options)}`, "--------------------------------------------------------------------", originalError ? originalError.stack || originalError.message : "Unknown error", "--------------------------------------------------------------------", "Please report at https: "====================================================================" ].join('\n'); super(message); this.name = 'GuessItException'; this.inputString = inputString; this.options = options; this.originalError = originalError; if (Error.captureStackTrace) { Error.captureStackTrace(this, GuessItException); } } } class ConfigurationException extends Error { constructor(message) { super(message); this.name = 'ConfigurationException'; if (Error.captureStackTrace) { Error.captureStackTrace(this, ConfigurationException); } } } const defaultConfig = { "expected_title": [ "OSS 117", "This is Us" ], "allowed_countries": [ "au", "gb", "us" ], "allowed_languages": [ "ca", "cs", "de", "en", "es", "fr", "he", "hi", "hu", "it", "ja", "ko", "mul", "nl", "no", "pl", "pt", "ro", "ru", "sv", "te", "uk", "und" ], "advanced_config": { "common_words": [ "ca", "cat", "de", "he", "it", "no", "por", "rum", "se", "st", "sub" ], "groups": { "starting": "([{", "ending": ")]}" }, "audio_codec": { "audio_codec": { "MP3": { "patterns": ["MP3", "LAME"], "regex": ["LAME(?:\\d)+-?(?:\\d)+"] }, "MP2": { "patterns": ["MP2"] }, "Dolby Digital": { "patterns": ["Dolby", "DolbyDigital"], "regex": ["Dolby-Digital", "DD", "AC-?3D?"] }, "Dolby Atmos": { "patterns": ["Atmos"], "regex": ["Dolby-?Atmos"] }, "AAC": { "patterns": ["AAC"] }, "Dolby Digital Plus": { "patterns": ["DDP", "DD+"], "regex": ["E-?AC-?3"] }, "FLAC": { "patterns": ["Flac"] }, "DTS": { "patterns": ["DTS"] }, "DTS-HD": { "regex": ["DTS-?HD", "DTS(?=-?MA)"] }, "DTS:X": { "patterns": ["DTS:X", "DTS-X", "DTSX"] }, "Dolby TrueHD": { "regex": ["True-?HD"] }, "Opus": { "patterns": ["Opus"] }, "Vorbis": { "patterns": ["Vorbis"] }, "PCM": { "patterns": ["PCM"] }, "LPCM": { "patterns": ["LPCM"] } } }, "container": { "subtitles": ["srt", "idx", "sub", "ssa", "ass"], "info": ["nfo"], "videos": [ "3g2", "3gp", "3gp2", "asf", "avi", "divx", "flv", "iso", "m4v", "mk2", "mk3d", "mka", "mkv", "mov", "mp4", "mp4a", "mpeg", "mpg", "ogg", "ogm", "ogv", "qt", "ra", "ram", "rm", "ts", "m2ts", "vob", "wav", "webm", "wma", "wmv" ], "torrent": ["torrent"], "nzb": ["nzb"] }, "episodes": { "season_max_range": 100, "episode_max_range": 100, "max_range_gap": 1, "season_markers": ["s"], "season_ep_markers": ["x"], "disc_markers": ["d"], "episode_markers": ["xe", "ex", "ep", "e", "x"], "range_separators": ["-", "~", "to", "a"], "discrete_separators": ["+", "&", "and", "et"], "season_words": [ "season", "saison", "seizoen", "seasons", "saisons", "tem", "temp", "temporada", "temporadas", "stagione" ], "episode_words": [ "episode", "episodes", "eps", "ep", "episodio", "episodios", "capitulo", "capitulos" ], "of_words": ["of", "sur"], "all_words": ["All"] }, "language": { "synonyms": { "ell": ["gr", "greek"], "spa": ["esp", "español", "espanol"], "fra": ["français", "vf", "vff", "vfi", "vfq"], "swe": ["se"], "por_BR": ["po", "pb", "pob", "ptbr", "br", "brazilian"], "deu_CH": ["swissgerman", "swiss german"], "nld_BE": ["flemish"], "cat": ["català", "castellano", "espanol castellano", "español castellano"], "ces": ["cz"], "ukr": ["ua"], "zho": ["cn"], "jpn": ["jp"], "hrv": ["scr"], "mul": ["multi", "multiple", "dl"] } }, "screen_size": { "frame_rates": [ "23\\.976", "24(?:\\.0{1,3})?", "25(?:\\.0{1,3})?", "29\\.970", "30(?:\\.0{1,3})?", "48(?:\\.0{1,3})?", "50(?:\\.0{1,3})?", "60(?:\\.0{1,3})?", "120(?:\\.0{1,3})?" ], "min_ar": 1.333, "max_ar": 1.898, "interlaced": ["360", "480", "540", "576", "900", "1080"], "progressive": ["360", "480", "540", "576", "900", "1080", "368", "720", "1440", "2160", "4320"] }, "source": { "rip_prefix": "(?P<other>Rip)-?", "rip_suffix": "-?(?P<other>Rip)" }, "website": { "safe_tlds": ["com", "net", "org"], "safe_subdomains": ["www"], "safe_prefixes": ["co", "com", "net", "org"], "prefixes": ["from"] } } }; function parseOptions(options = null, api = false) { if (typeof options === 'string') { const args = options.split(/\s+/).filter(arg => arg.length > 0); return parseArgs(args); } else if (options === null || options === undefined) { return api ? {} : {}; } else if (Array.isArray(options)) { return parseArgs(options); } else if (typeof options === 'object') { return { ...options }; } return {}; } function parseArgs(args) { const options = {}; for (let i = 0; i < args.length; i++) { const arg = args[i]; if (arg.startsWith('--')) { const key = arg.slice(2).replace(/-/g, '_'); if (i + 1 < args.length && !args[i + 1].startsWith('-')) { options[key] = args[++i]; } else { options[key] = true; } } else if (arg.startsWith('-') && arg.length === 2) { const key = getShortOptionKey(arg[1]); if (key) { if (i + 1 < args.length && !args[i + 1].startsWith('-')) { options[key] = args[++i]; } else { options[key] = true; } } } else if (!arg.startsWith('-')) { if (!options.filename) { options.filename = [arg]; } else { options.filename.push(arg); } } } return options; } function getShortOptionKey(shortOpt) { const mapping = { 't': 'type', 'n': 'name_only', 'Y': 'date_year_first', 'D': 'date_day_first', 'L': 'allowed_languages', 'C': 'allowed_countries', 'E': 'episode_prefer_number', 'T': 'expected_title', 'G': 'expected_group', 'f': 'input_file', 'v': 'verbose', 'P': 'show_property', 'a': 'advanced', 's': 'single_value', 'l': 'enforce_list', 'j': 'json', 'y': 'yaml', 'i': 'output_input_string', 'c': 'config', 'p': 'properties', 'V': 'values' }; return mapping[shortOpt]; } function loadConfig(options = {}) { const configurations = []; if (!options.no_default_config) { configurations.push(defaultConfig); } let config = {}; if (configurations.length > 0) { config = mergeOptions(...configurations); } if (!config.advanced_config && defaultConfig.advanced_config) { config.advanced_config = defaultConfig.advanced_config; } return config; } function mergeOptions(...optionsArray) { let merged = {}; for (const options of optionsArray) { if (!options) continue; const pristine = options.pristine; if (pristine === true) { merged = {}; } else if (Array.isArray(pristine)) { for (const key of pristine) { delete merged[key]; } } for (const [key, value] of Object.entries(options)) { mergeOptionValue(key, value, merged); } } return merged; } function mergeOptionValue(option, value, merged) { if (value !== null && value !== undefined && option !== 'pristine') { if (merged[option] && Array.isArray(merged[option])) { const values = Array.isArray(value) ? value : [value]; for (const val of values) { if (val !== null && val !== undefined && !merged[option].includes(val)) { merged[option].push(val); } } } else if (merged[option] && typeof merged[option] === 'object' && typeof value === 'object') { merged[option] = mergeOptions(merged[option], value); } else if (Array.isArray(value)) { merged[option] = [...value]; } else { merged[option] = value; } } } class Match { constructor(start, end, value = null, name = null, options = {}) { this.start = start; this.end = end; this.value = value !== null ? value : ''; this.name = name; this.tags = options.tags || []; this.private = options.private || false; this.children = options.children || []; this.parent = options.parent || null; this.raw = options.raw || ''; this.initiator = options.initiator || null; this.formatter = options.formatter || null; this.validator = options.validator || null; } get span() { return [this.start, this.end]; } get length() { return this.end - this.start; } format() { if (this.formatter && typeof this.formatter === 'function') { try { this.value = this.formatter(this.value); } catch (error) { console.warn('Formatting failed for match:', this, error); } } } validate() { if (this.validator && typeof this.validator === 'function') { try { return this.validator(this); } catch (error) { console.warn('Validation failed for match:', this, error); return false; } } return true; } split(separators, valueFunction = null) { const parts = []; let currentStart = this.start; for (let i = this.start; i < this.end; i++) { const char = this.raw[i - this.start]; if (separators.includes(char)) { if (currentStart < i) { const part = new Match(currentStart, i); part.raw = this.raw.slice(currentStart - this.start, i - this.start); part.value = valueFunction ? valueFunction(part) : part.raw; parts.push(part); } currentStart = i + 1; } } if (currentStart < this.end) { const part = new Match(currentStart, this.end); part.raw = this.raw.slice(currentStart - this.start); part.value = valueFunction ? valueFunction(part) : part.raw; parts.push(part); } return parts; } } class Matches { constructor(inputString = '') { this.inputString = inputString; this.matches = []; this.markers = new Markers(); } add(match) { if (match instanceof Match) { this.matches.push(match); } } named(name, predicate = null) { const filtered = this.matches.filter(match => match.name === name); return predicate ? filtered.filter(predicate) : filtered; } tagged(tag, predicate = null) { const filtered = this.matches.filter(match => match.tags.includes(tag)); return predicate ? filtered.filter(predicate) : filtered; } range(start, end, predicate = null, index = null) { let filtered = this.matches.filter(match => match.start >= start && match.end <= end ); if (predicate) { filtered = filtered.filter(predicate); } if (index !== null) { return filtered[index] || null; } return filtered; } previous(match, predicate = null, index = 0) { let candidates = this.matches.filter(m => m.end <= match.start); if (predicate) { candidates = candidates.filter(predicate); } candidates.sort((a, b) => b.end - a.end); return candidates[index] || null; } next(match, predicate = null, index = 0) { let candidates = this.matches.filter(m => m.start >= match.end); if (predicate) { candidates = candidates.filter(predicate); } candidates.sort((a, b) => a.start - b.start); return candidates[index] || null; } holes(start, end, options = {}) { const holes = []; const rangeMatches = this.range(start, end).sort((a, b) => a.start - b.start); let currentPos = start; for (const match of rangeMatches) { if (match.start > currentPos) { const hole = new Match(currentPos, match.start); hole.raw = this.inputString.slice(currentPos, match.start); hole.value = hole.raw; holes.push(hole); } currentPos = Math.max(currentPos, match.end); } if (currentPos < end) { const hole = new Match(currentPos, end); hole.raw = this.inputString.slice(currentPos, end); hole.value = hole.raw; holes.push(hole); } return holes; } toDict(advanced = false, singleValue = false, enforceList = false) { const result = {}; const propertyGroups = {}; for (const match of this.matches) { if (match.private) continue; if (!propertyGroups[match.name]) { propertyGroups[match.name] = []; } propertyGroups[match.name].push(match.value); } for (const [property, values] of Object.entries(propertyGroups)) { const uniqueValues = [...new Set(values)]; if (singleValue && uniqueValues.length > 0) { result[property] = uniqueValues[0]; } else if (enforceList || uniqueValues.length > 1) { result[property] = uniqueValues; } else if (uniqueValues.length === 1) { result[property] = uniqueValues[0]; } } if (result.season_episode && typeof result.season_episode === 'object') { const seasonEpisode = result.season_episode; if (seasonEpisode.season !== undefined) { result.season = seasonEpisode.season; } if (seasonEpisode.episode !== undefined) { result.episode = seasonEpisode.episode; } } return result; } } class Markers { constructor() { this.markerList = []; } add(marker) { this.markerList.push(marker); } named(name) { return this.markerList.filter(marker => marker.name === name); } atMatch(match, predicate = null, index = 0) { let candidates = this.markerList.filter(marker => marker.start <= match.start && marker.end >= match.end ); if (predicate) { candidates = candidates.filter(predicate); } return candidates[index] || null; } starting(position, predicate = null) { let candidates = this.markerList.filter(marker => marker.start === position); if (predicate) { candidates = candidates.filter(predicate); } return candidates; } } class Rule { constructor(pattern, options = {}) { this.pattern = pattern; this.name = options.name || null; this.value = options.value || null; this.tags = options.tags || []; this.formatter = options.formatter || null; this.validator = options.validator || null; this.private = options.private || false; this.children = options.children || false; this.conflictSolver = options.conflictSolver || null; } apply(inputString, matches, options = {}) { let regex; if (this.pattern instanceof RegExp) { regex = this.pattern; } else if (typeof this.pattern === 'string') { const flags = options.ignoreCase ? 'gi' : 'g'; regex = new RegExp(this.pattern, flags); } else { return []; } const isDebugging = (typeof process !== 'undefined' && process.env && process.env.DEBUG_RULES === 'true') || false; if (isDebugging && this.name === 'container') { console.log(`[DEBUG] Applying ${this.name} rule with pattern ${regex} to "${inputString}"`); } const newMatches = []; let match; let lastIndex = 0; let iterations = 0; const maxIterations = 1000; while ((match = regex.exec(inputString)) !== null && iterations < maxIterations) { iterations++; if (match.index === lastIndex && match[0].length === 0) { regex.lastIndex = lastIndex + 1; continue; } lastIndex = match.index + match[0].length; const matchObj = new Match( match.index, match.index + match[0].length, this.value || match[0], this.name, { tags: [...this.tags], private: this.private, raw: match[0], formatter: this.formatter, validator: this.validator } ); if (isDebugging && this.name === 'container' && match) { console.log(`[DEBUG] Found match: ${JSON.stringify(match)} -> matchObj: ${JSON.stringify({start: matchObj.start, end: matchObj.end, name: matchObj.name, value: matchObj.value})}`); } matchObj.format(); const isValid = matchObj.validate(); if (isDebugging && this.name === 'container' && match) { console.log(`[DEBUG] Validation result: ${isValid}`); } if (isValid) { newMatches.push(matchObj); if (isDebugging && this.name === 'container') { console.log(`[DEBUG] Added match to newMatches, total: ${newMatches.length}`); } } if (!regex.global) { break; } } if (isDebugging && this.name === 'container') { console.log(`[DEBUG] Returning ${newMatches.length} matches from ${this.name} rule`); } return newMatches; } } class Rebulk { constructor(options = {}) { this.rules = []; this.options = { ignoreCase: options.ignoreCase || false, ...options }; } addRules(rules) { if (Array.isArray(rules)) { this.rules.push(...rules); } else if (rules) { this.rules.push(rules); } } string(pattern, options = {}) { const rule = new Rule(pattern, options); this.rules.push(rule); return this; } regex(pattern, options = {}) { const rule = new Rule(new RegExp(pattern, this.options.ignoreCase ? 'gi' : 'g'), options); this.rules.push(rule); return this; } matches(inputString, options = {}) { const matches = new Matches(inputString); const mergedOptions = { ...this.options, ...options }; this.addPathMarkers(matches, inputString); for (const rule of this.rules) { const ruleMatches = rule.apply(inputString, matches, mergedOptions); const isDebugging = (typeof process !== 'undefined' && process.env && process.env.DEBUG_RULES === 'true') || false; if (isDebugging && rule.name === 'container' && ruleMatches.length > 0) { console.log(`[DEBUG] Rule ${rule.name} returned ${ruleMatches.length} matches`); } for (const match of ruleMatches) { matches.add(match); if (isDebugging && rule.name === 'container') { console.log(`[DEBUG] Added match to collection, total matches: ${matches.matches.length}`); } } } this.postProcessMatches(matches); return matches; } addPathMarkers(matches, inputString) { const pathSeparators = /[\/\\]/g; const parts = inputString.split(pathSeparators); let currentPos = 0; for (let i = 0; i < parts.length; i++) { const part = parts[i]; if (part.length > 0) { const marker = new Match(currentPos, currentPos + part.length); marker.name = 'path'; marker.private = true; matches.markers.add(marker); } currentPos += part.length + 1; } } postProcessMatches(matches) { const isDebugging = (typeof process !== 'undefined' && process.env && process.env.DEBUG_RULES === 'true') || false; if (isDebugging) { console.log(`[DEBUG] Post-processing ${matches.matches.length} matches`); matches.matches.forEach((match, i) => { console.log(`[DEBUG] ${i}: ${match.start}-${match.end} "${match.name}": "${match.value}" (private: ${match.private})`); }); } const privateMatches = matches.matches.filter(m => m.private); const publicMatches = matches.matches.filter(m => !m.private); if (isDebugging) { console.log(`[DEBUG] Separated into ${privateMatches.length} private and ${publicMatches.length} public matches`); } publicMatches.sort((a, b) => a.start - b.start || (b.end - b.start) - (a.end - a.start)); const getMatchPriority = (match) => { const priorities = { 'container': 100, 'video_codec': 90, 'audio_codec': 90, 'source': 80, 'screen_size': 80, 'year': 70, 'episode': 60, 'season': 60, 'title': 10, 'cleanup': 5, 'path': 1 }; return priorities[match.name] || 50; }; const filtered = []; for (const match of publicMatches) { const overlapping = filtered.filter(existing => !(match.end <= existing.start || match.start >= existing.end) ); if (overlapping.length === 0) { filtered.push(match); if (isDebugging) { console.log(`[DEBUG] Keeping non-overlapping match: ${match.name} (${match.start}-${match.end})`); } } else { if (isDebugging) { console.log(`[DEBUG] Found ${overlapping.length} overlapping matches for ${match.name} (${match.start}-${match.end})`); } const currentPriority = getMatchPriority(match); let shouldReplace = false; let toReplace = []; for (const existing of overlapping) { const existingPriority = getMatchPriority(existing); if (currentPriority > existingPriority) { shouldReplace = true; toReplace.push(existing); } else if (currentPriority === existingPriority && match.length > existing.length) { shouldReplace = true; toReplace.push(existing); } } if (shouldReplace) { for (const existing of toReplace) { const index = filtered.indexOf(existing); if (index !== -1) { filtered.splice(index, 1); } } filtered.push(match); if (isDebugging) { console.log(`[DEBUG] Replaced ${toReplace.length} lower priority matches with ${match.name} (priority: ${currentPriority})`); } } else { if (isDebugging) { console.log(`[DEBUG] Discarding ${match.name} (priority: ${currentPriority}) in favor of higher priority matches`); } } } } const finalMatches = [...filtered, ...privateMatches]; if (isDebugging) { console.log(`[DEBUG] After post-processing: ${finalMatches.length} matches (${filtered.length} public + ${privateMatches.length} private)`); finalMatches.forEach((match, i) => { console.log(`[DEBUG] ${i}: ${match.start}-${match.end} "${match.name}": "${match.value}" (private: ${match.private})`); }); } matches.matches = finalMatches; } introspect(options = {}) { const properties = {}; for (const rule of this.rules) { if (rule.name && !rule.private) { if (!properties[rule.name]) { properties[rule.name] = new Set(); } if (rule.value) { properties[rule.name].add(rule.value); } } } return { properties }; } } function episodeRules(config) { const rules = []; const seasonMarkers = config.season_markers || ['s']; const episodeMarkers = config.episode_markers || ['e', 'ep', 'x']; const rangeSeparators = config.range_separators || ['-', '~', 'to']; const discreteSeparators = config.discrete_separators || ['+', '&', 'and']; rules.push(new Rule( /([Ss])(\d{1,2})[\s\-\.]*([Ee])(\d{1,3})/g, { name: 'season_episode', formatter: (value) => { const match = value.match(/([Ss])(\d{1,2})[\s\-\.]*([Ee])(\d{1,3})/); if (match) { return { season: parseInt(match[2], 10), episode: parseInt(match[4], 10) }; } return value; }, tags: ['SxxExx'] } )); rules.push(new Rule( /(\d{1,2})x(\d{1,3})/gi, { name: 'season_episode', formatter: (value) => { const match = value.match(/(\d{1,2})x(\d{1,3})/i); if (match) { return { season: parseInt(match[1], 10), episode: parseInt(match[2], 10) }; } return value; }, tags: ['NxNN'] } )); rules.push(new Rule( /[Ss](\d{1,2})/g, { name: 'season', formatter: (value) => { const match = value.match(/(\d+)/); return match ? parseInt(match[1], 10) : value; }, tags: ['season-only'] } )); rules.push(new Rule( /[Ee](\d{1,3})/g, { name: 'episode', formatter: (value) => { const match = value.match(/(\d+)/); return match ? parseInt(match[1], 10) : value; }, tags: ['episode-only'] } )); rules.push(new Rule( /\b(?:episode|episodes)\s*(\d{1,3})\b/gi, { name: 'episode', formatter: (value) => { const match = value.match(/(\d+)/); return match ? parseInt(match[1], 10) : value; }, tags: ['episode-word'] } )); rules.push(new Rule( /\b(?:season|seasons)\s*(\d{1,2})\b/gi, { name: 'season', formatter: (value) => { const match = value.match(/(\d+)/); return match ? parseInt(match[1], 10) : value; }, tags: ['season-word'] } )); const episodeDetails = ['Special', 'Pilot', 'Unaired', 'Final']; for (const detail of episodeDetails) { rules.push(new Rule( detail, { name: 'episode_details', value: detail, tags: ['episode-detail'] } )); } return rules; } function titleRules(config) { const rules = []; rules.push(new Rule( /^(?:\[[^\]]*\]\.?)([a-zA-Z\u00C0-\u017F\u4e00-\u9fff][a-zA-Z0-9\u00C0-\u017F\u4e00-\u9fff\s\-\.\'\:]*?)(?=[\.\s\-](19|20)\d{2}|[\.\s\-]\d{3,4}p|[\.\s\-](?:bluray|hdtv|web|dvd|cam|x264|x265|h264|h265|xvid|divx|dts|aac|mkv|avi|mp4|french|english|german|spanish|italian))/gi, { name: 'title', formatter: (value) => { return value .replace(/[\.\-_]/g, ' ') .replace(/\s+/g, ' ') .trim(); }, validator: (match) => { const value = match.value.trim(); return value.length >= 2 && !/^\d+$/.test(value); }, tags: ['title-unicode'] } )); rules.push(new Rule( /^([a-zA-Z\u00C0-\u017F\u4e00-\u9fff][a-zA-Z0-9\u00C0-\u017F\u4e00-\u9fff\s\-\.\'\:]*?)(?=[\.\s\-](19|20)\d{2}|[\.\s\-]\d{3,4}p|[\.\s\-](?:bluray|hdtv|web|dvd|cam|x264|x265|h264|h265|xvid|divx|dts|aac|mkv|avi|mp4|french|english|german|spanish|italian))/gi, { name: 'title', formatter: (value) => { return value .replace(/[\.\-_]/g, ' ') .replace(/\s+/g, ' ') .trim(); }, validator: (match) => { const value = match.value.trim(); return value.length >= 3 && !/^\d+$/.test(value); }, tags: ['title'] } )); rules.push(new Rule( /([a-zA-Z\u00C0-\u017F\u4e00-\u9fff][a-zA-Z0-9\u00C0-\u017F\u4e00-\u9fff\s]+[a-zA-Z0-9\u00C0-\u017F\u4e00-\u9fff])/g, { name: 'title', formatter: (value) => { return value .replace(/[\.\-_]/g, ' ') .replace(/\s+/g, ' ') .trim(); }, validator: (match) => { const value = match.value.trim(); const skipTerms = ['bluray', 'hdtv', 'web', 'dvd', 'x264', 'x265', 'h264', 'h265', 'xvid', 'divx', 'aac', 'dts', 'french', 'english']; return value.length >= 4 && !/^\d+$/.test(value) && !skipTerms.includes(value.toLowerCase()); }, tags: ['title-fallback'], private: false } )); return rules; } function videoCodecRules(config) { const rules = []; const videoCodecs = { 'H.264': ['h264', 'h.264', 'x264', 'avc'], 'H.265': ['h265', 'h.265', 'x265', 'hevc'], 'XviD': ['xvid'], 'DivX': ['divx'], 'VP9': ['vp9'], 'AV1': ['av1'], 'MPEG-2': ['mpeg2', 'mpeg-2'], 'VC-1': ['vc1', 'vc-1'], 'WMV': ['wmv'] }; for (const [codecName, patterns] of Object.entries(videoCodecs)) { for (const pattern of patterns) { rules.push(new Rule( new RegExp(`\\b${pattern}\\b`, 'i'), { name: 'video_codec', value: codecName, tags: ['video-codec'] } )); } } return rules; } function screenSizeRules(config) { const rules = []; const resolutions = { '240p': ['240p'], '360p': ['360p'], '480p': ['480p', 'sd'], '720p': ['720p', 'hd'], '1080p': ['1080p', '1080i', 'fhd', 'fullhd', 'full hd'], '1440p': ['1440p', '2k'], '2160p': ['2160p', '4k', 'uhd', 'ultra hd'], '4320p': ['4320p', '8k'] }; for (const [size, patterns] of Object.entries(resolutions)) { for (const pattern of patterns) { rules.push(new Rule( new RegExp(`\\b${pattern}\\b`, 'i'), { name: 'screen_size', value: size, tags: ['resolution'] } )); } } rules.push(new Rule( /(\d{3,4})x(\d{3,4})/gi, { name: 'screen_size', formatter: (value) => { const match = value.match(/(\d{3,4})x(\d{3,4})/i); if (match) { const width = parseInt(match[1], 10); const height = parseInt(match[2], 10); if (width === 1920 && height === 1080) return '1080p'; if (width === 1280 && height === 720) return '720p'; if (width === 3840 && height === 2160) return '2160p'; if (width === 2560 && height === 1440) return '1440p'; return `${width}x${height}`; } return value; }, tags: ['resolution', 'dimensions'] } )); return rules; } function containerRules(config) { const rules = []; const containers = { videos: config.videos || [ '3g2', '3gp', '3gp2', 'asf', 'avi', 'divx', 'flv', 'iso', 'm4v', 'mk2', 'mk3d', 'mka', 'mkv', 'mov', 'mp4', 'mp4a', 'mpeg', 'mpg', 'ogg', 'ogm', 'ogv', 'qt', 'ra', 'ram', 'rm', 'ts', 'm2ts', 'vob', 'wav', 'webm', 'wma', 'wmv' ], subtitles: config.subtitles || ['srt', 'idx', 'sub', 'ssa', 'ass'], info: config.info || ['nfo'], torrent: config.torrent || ['torrent'], nzb: config.nzb || ['nzb'] }; for (const [type, extensions] of Object.entries(containers)) { for (const ext of extensions) { rules.push(new Rule( new RegExp(`\\.${ext}$`, 'i'), { name: 'container', value: ext.toLowerCase(), tags: ['container', type] } )); } } return rules; } function sourceRules(config) { const rules = []; const sources = { 'BluRay': ['bluray'], 'Blu-ray': ['blu-ray', 'bdrip', 'brrip'], 'HD-DVD': ['hddvd', 'hd-dvd'], 'HDTV': ['hdtv'], 'WEB': ['web', 'webrip', 'web-dl', 'webdl'], 'DVD': ['dvd', 'dvdrip'], 'CAM': ['cam', 'camrip'], 'Telesync': ['ts', 'telesync'], 'Telecine': ['tc', 'telecine'], 'Screener': ['scr', 'screener'], 'VHS': ['vhs'] }; for (const [sourceName, patterns] of Object.entries(sources)) { for (const pattern of patterns) { rules.push(new Rule( new RegExp(`\\b${pattern}\\b`, 'i'), { name: 'source', value: sourceName, tags: ['source'] } )); } } return rules; } function audioCodecRules(config) { const rules = []; const audioCodecs = { 'DTS': ['dts'], 'DTS-HD': ['dts-hd', 'dtshd'], 'DTS:X': ['dts:x', 'dts-x', 'dtsx'], 'Dolby Digital': ['dd', 'ac3', 'dolby'], 'Dolby Digital Plus': ['dd+', 'ddp', 'e-ac3'], 'Dolby Atmos': ['atmos'], 'Dolby TrueHD': ['truehd', 'true-hd'], 'AAC': ['aac'], 'MP3': ['mp3'], 'FLAC': ['flac'], 'PCM': ['pcm'], 'LPCM': ['lpcm'] }; for (const [codecName, patterns] of Object.entries(audioCodecs)) { for (const pattern of patterns) { rules.push(new Rule( new RegExp(`\\b${pattern}\\b`, 'i'), { name: 'audio_codec', value: codecName, tags: ['audio-codec'] } )); } } return rules; } function websiteRules(config) { return []; } function dateRules(config) { const rules = []; rules.push(new Rule( /\b(19[0-9]{2}|20[0-9]{2})\b/g, { name: 'year', formatter: (value) => parseInt(value, 10), validator: (match) => { const year = parseInt(match.value, 10); return year >= 1900 && year <= 2099; }, tags: ['date'] } )); return rules; } function episodeTitleRules(config) { return []; } function languageRules(config, commonWords) { return []; } function countryRules(config, commonWords) { return []; } function releaseGroupRules(config) { const rules = []; rules.push(new Rule( /(?<=-)[A-Z0-9]+(?=\.(?:mkv|avi|mp4|mov|wmv|flv|webm|m4v|3gp|ts|m2ts|vob|iso|img|bin|mdf|nrg|cue|rar|zip|7z|tar|gz|bz2|xz)$)/gi, { name: 'release_group', validator: (match) => { const group = match.value; const excludeWords = ['REPACK', 'PROPER', 'REAL', 'FINAL', 'COMPLETE', 'UNCUT', 'EXTENDED', 'DIRECTORS', 'CUT']; return group.length >= 2 && group.length <= 20 && !excludeWords.includes(group.toUpperCase()); }, tags: ['release-group'] } )); rules.push(new Rule( /[\[\(]([A-Z0-9\-_.]+)[\]\)]/gi, { name: 'release_group', formatter: (value) => { const match = value.match(/[\[\(]([A-Z0-9\-_.]+)[\]\)]/i); return match ? match[1] : value; }, validator: (match) => { const group = match.value; if (/^(19|20)\d{2}$/.test(group)) return false; if (/^\d{1,4}$/.test(group)) return false; return group.length >= 2 && group.length <= 20; }, tags: ['release-group-bracket'] } )); return rules; } function streamingServiceRules(config) { return []; } function otherRules(config) { return []; } function sizeRules(config) { return []; } function bitRateRules(config) { return []; } function editionRules(config) { return []; } function cdRules(config) { return []; } function bonusRules(config) { return []; } function filmRules(config) { return []; } function partRules(config) { return []; } function crcRules(config) { return []; } function mimetypeRules(config) { return []; } function typeRules(config) { return []; } function pathRules(config) { const rules = []; rules.push(new Rule( /([^\/\\]+)/g, { name: 'path', private: true, tags: ['path-segment'] } )); return rules; } function groupRules(config) { const rules = []; const starting = config.starting || '([{'; const ending = config.ending || ')]}'; const pairs = []; for (let i = 0; i < Math.min(starting.length, ending.length); i++) { pairs.push([starting[i], ending[i]]); } for (const [open, close] of pairs) { rules.push(new Rule( new RegExp(`\\${open}([^\\${open}\\${close}]+)\\${close}`, 'g'), { name: 'group', private: true, tags: ['group-marker'] } )); } return rules; } function processorsRules(config) { const rules = []; rules.push(new Rule( /.*/, { name: 'cleanup', private: true, processor: true, apply: (matches) => { const seen = new Set(); matches.matches = matches.matches.filter(match => { const key = `${match.name}-${match.start}-${match.end}`; if (seen.has(key)) { return false; } seen.add(key); return true; }); return matches; } } )); return rules; } function RebulkBuilder(config) { function getConfig(name) { return config[name] || {}; } const rebulk = new Rebulk(); const commonWordsConfig = getConfig('common_words'); const commonWords = new Set(Array.isArray(commonWordsConfig) ? commonWordsConfig : []); rebulk.addRules(pathRules(getConfig('path'))); rebulk.addRules(groupRules(getConfig('groups'))); rebulk.addRules(episodeRules(getConfig('episodes'))); rebulk.addRules(containerRules(getConfig('container'))); rebulk.addRules(sourceRules(getConfig('source'))); rebulk.addRules(videoCodecRules(getConfig('video_codec'))); rebulk.addRules(audioCodecRules(getConfig('audio_codec'))); rebulk.addRules(screenSizeRules(getConfig('screen_size'))); rebulk.addRules(websiteRules(getConfig('website'))); rebulk.addRules(dateRules(getConfig('date'))); rebulk.addRules(titleRules(getConfig('title'))); rebulk.addRules(episodeTitleRules(getConfig('episode_title'))); rebulk.addRules(languageRules(getConfig('language'), commonWords)); rebulk.addRules(countryRules(getConfig('country'), commonWords)); rebulk.addRules(releaseGroupRules(getConfig('release_group'))); rebulk.addRules(streamingServiceRules(getConfig('streaming_service'))); rebulk.addRules(otherRules(getConfig('other'))); rebulk.addRules(sizeRules(getConfig('size'))); rebulk.addRules(bitRateRules(getConfig('bit_rate'))); rebulk.addRules(editionRules(getConfig('edition'))); rebulk.addRules(cdRules(getConfig('cd'))); rebulk.addRules(bonusRules(getConfig('bonus'))); rebulk.addRules(filmRules(getConfig('film'))); rebulk.addRules(partRules(getConfig('part'))); rebulk.addRules(crcRules(getConfig('crc'))); rebulk.addRules(processorsRules(getConfig('processors'))); rebulk.addRules(mimetypeRules(getConfig('mimetype'))); rebulk.addRules(typeRules(getConfig('type'))); rebulk.customizeProperties = function(properties) { if (properties.count) { const count = properties.count; delete properties.count; properties.season_count = count; properties.episode_count = count; } return properties; }; return rebulk; } class GuessItApi { constructor() { this.rebulk = null; this.config = null; this.loadConfigOptions = null; this.advancedConfig = null; } reset() { this.rebulk = null; this.config = null; this.loadConfigOptions = null; this.advancedConfig = null; } static _fixEncoding(value) { if (Array.isArray(value)) { return value.map(item => GuessItApi._fixEncoding(item)); } if (value && typeof value === 'object') { const result = {}; for (const [k, v] of Object.entries(value)) { result[GuessItApi._fixEncoding(k)] = GuessItApi._fixEncoding(v); } return result; } return value; } static _hasSameProperties(dict1, dict2, values) { for (const value of values) { if (dict1[value] !== dict2[value]) { return false; } } return true; } configure(options = null, rulesBuilder = null, force = false, sanitizeOptions = true) { if (!rulesBuilder) { rulesBuilder = RebulkBuilder; } if (sanitizeOptions) { options = parseOptions(options, true); options = GuessItApi._fixEncoding(options); } const needsConfigReload = !this.config || !this.loadConfigOptions || force || !GuessItApi._hasSameProperties( this.loadConfigOptions, options, ['config', 'no_user_config', 'no_default_config'] ); let config; if (needsConfigReload) { config = loadConfig(options); config = GuessItApi._fixEncoding(config); this.loadConfigOptions = { ...options }; } else { config = this.config; } const advancedConfig = mergeOptions( config.advanced_config || {}, options.advanced_config || {} ); const needsRebulkRebuild = force || !this.rebulk || !this.advancedConfig || JSON.stringify(this.advancedConfig) !== JSON.stringify(advancedConfig); if (needsRebulkRebuild) { this.advancedConfig = JSON.parse(JSON.stringify(advancedConfig)); this.rebulk = rulesBuilder(advancedConfig); } this.config = config; return this.config; } guessit(filename, options = null) { try { if (filename && typeof filename === 'object' && filename.toString) { filename = filename.toString(); } options = parseOptions(options, true); options = GuessItApi._fixEncoding(options); const config = this.configure(options, null, false, false); options = mergeOptions(config, options); const matches = this.rebulk.matches(filename, options); const matchesDict = matches.toDict( options.advanced || false, options.single_value || false, options.enforce_list || false ); if (options.output_input_string) { matchesDict.input_string = filename; } return matchesDict; } catch (error) { throw new GuessItException(filename, options, error); } } properties(options = null) { options = parseOptions(options, true); options = GuessItApi._fixEncoding(options); const config = this.configure(options, null, false, false); options = mergeOptions(config, options); const unordered = this.rebulk.introspect(options).properties; const ordered = {}; const sortedKeys = Object.keys(unordered).sort(); for (const key of sortedKeys) { ordered[key] = Array.from(unordered[key]).sort(); } if (this.rebulk.customizeProperties) { return this.rebulk.customizeProperties(ordered); } return ordered; } suggestedExpected(titles, options = null) { const suggested = []; for (const title of titles) { const guess = this.guessit(title, options); if (Object.keys(guess).length !== 2 || !guess.title) { suggested.push(title); } } return suggested; } } const defaultApi = new GuessItApi(); function configure(options = null, rulesBuilder = null, force = false) { defaultApi.configure(options, rulesBuilder, force); } function reset() { defaultApi.reset(); } function guessit(filename, options = null) { return defaultApi.guessit(filename, options); } function properties(options = null) { return defaultApi.properties(options); } function suggestedExpected(titles, options = null) { return defaultApi.suggestedExpected(titles, options); } if (typeof module !== 'undefined' && module.exports) { module.exports = { guessit, configure, reset, properties, suggestedExpected, GuessItApi, GuessItException, parseOptions, loadConfig, mergeOptions }; } else if (typeof window !== 'undefined') { window.GuessIt = { guessit, configure, reset, properties, suggestedExpected, GuessItApi, GuessItException }; } else { globalThis.GuessIt = { guessit, configure, reset, properties, suggestedExpected, GuessItApi, GuessItException }; }